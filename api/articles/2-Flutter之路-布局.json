{"title":"2. Flutter之路-布局","slug":"2-Flutter之路-布局","date":"2019-08-09T07:16:53.000Z","updated":"2019-08-13T05:33:25.000Z","comments":true,"path":"api/articles/2-Flutter之路-布局.json","photos":[],"link":"","excerpt":"2. Flutter之路-布局","covers":null,"content":"<h1 id=\"2-Flutter之路-布局\"><a href=\"#2-Flutter之路-布局\" class=\"headerlink\" title=\"2. Flutter之路-布局\"></a>2. Flutter之路-布局</h1><a id=\"more\"></a>\n<p>Flutter布局机制的核心就是widget。在Flutter中，几乎所有东西都是一个widget。甚至布局模型都是widget。在Flutter应用中看到的图像、图标和文本都是widget。 甚至你看不到的东西也是widget，例如行（row）、列（column）以及用来排列、约束和对齐这些可见widget的网格（grid）。</p>\n<h2 id=\"Widget\"><a href=\"#Widget\" class=\"headerlink\" title=\"Widget\"></a>Widget</h2><p>在Flutter中，我们平时自定义的widget，一般都是继承自<code>StatelessWidget</code>或<code>StatefulWidget</code>（并不是只有这两种），这两种widget也是目前最常用的两种。</p>\n<ul>\n<li>StatelessWidget：一般来说，继承此类的widget自身状态不会去改变，创建了就直接显示，不会有色值、大小或者其他属性的变化。</li>\n<li>StatefulWidget：widget需要动态的去改变或者相应一些状态，例如点击态、色值、内容区域等,就需要继承此类。</li>\n</ul>\n<h3 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h3><p><code>Container</code>在Flutter中极其常用，官方定义是<code>Container</code>是一个拥有绘制、定位、调整大小的 widget。它是一个便利的小部件，结合了常见的绘画，定位和大小调整小部件。<br>由于Container结合了许多其他小部件，每个小部件都有自己的布局行为，因此Container的布局行为有点复杂。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    this<span class=\"selector-class\">.alignment</span>,</span><br><span class=\"line\">    this<span class=\"selector-class\">.padding</span>,</span><br><span class=\"line\">    Color <span class=\"attribute\">color</span>,</span><br><span class=\"line\">    Decoration decoration,</span><br><span class=\"line\">    this<span class=\"selector-class\">.foregroundDecoration</span>,</span><br><span class=\"line\">    double <span class=\"attribute\">width</span>,</span><br><span class=\"line\">    double <span class=\"attribute\">height</span>,</span><br><span class=\"line\">    BoxConstraints constraints,</span><br><span class=\"line\">    this<span class=\"selector-class\">.margin</span>,</span><br><span class=\"line\">    this<span class=\"selector-class\">.transform</span>,</span><br><span class=\"line\">    this<span class=\"selector-class\">.child</span>,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>key：Container唯一标识符，用于查找更新。</li>\n<li>alignment：控制child的对齐方式，如果container或者container父节点尺寸大于child的尺寸，这个属性设置会起作用，有很多种对齐方式。</li>\n<li>padding：decoration内部的空白区域，如果有child的话，child位于padding内部。padding与margin的不同之处在于，padding是包含在content内，而margin则是外部边界，设置点击事件的话，padding区域会响应，而margin区域不会响应。</li>\n<li>color：用来设置container背景色，如果foregroundDecoration设置的话，可能会遮盖color效果。</li>\n<li>decoration：绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。</li>\n<li>foregroundDecoration：绘制在child前面的装饰。</li>\n<li>width：container的宽度，设置为double.infinity可以强制在宽度上撑满，不设置，则根据child和父节点两者一起布局。</li>\n<li>height：container的高度，设置为double.infinity可以强制在高度上撑满。</li>\n<li>constraints：添加到child上额外的约束条件。</li>\n<li>margin：围绕在decoration和child之外的空白区域，不属于内容区域。</li>\n<li>transform：设置container的变换矩阵，类型为Matrix4。</li>\n<li>child：container中的内容widget。</li>\n</ul>\n<h3 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h3><p>Padding作为一个基础的控件，功能非常单一，给子节点设置padding属性。写过其他端的都了解这个属性，就是设置内边距属性，内边距的空白区域，也是widget的一部分。</p>\n<h3 id=\"Align\"><a href=\"#Align\" class=\"headerlink\" title=\"Align\"></a>Align</h3><p>Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。</p>\n<h3 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h3><p>对齐方式。一般会使用系统默认提供的9种方式。<br>Alignment实际上是包含了两个属性的，其中第一个参数，-1.0是左边对齐，1.0是右边对齐，第二个参数，-1.0是顶部对齐，1.0是底部对齐。</p>\n<h3 id=\"Center\"><a href=\"#Center\" class=\"headerlink\" title=\"Center\"></a>Center</h3><p>Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样。但没有设置alignment属性，是因为Align默认的对齐方式就是居中。</p>\n<h3 id=\"FittedBox\"><a href=\"#FittedBox\" class=\"headerlink\" title=\"FittedBox\"></a>FittedBox</h3><p>FittedBox是一个容器，它会在自己的尺寸范围内缩放并且调整child位置，使得child适合其尺寸。</p>\n<h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const FittedBox(&#123;</span><br><span class=\"line\">Key key,</span><br><span class=\"line\">this<span class=\"selector-class\">.fit</span>: BoxFit<span class=\"selector-class\">.contain</span>,</span><br><span class=\"line\">this<span class=\"selector-class\">.alignment</span>: Alignment<span class=\"selector-class\">.center</span>,</span><br><span class=\"line\">Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>fit：缩放的方式，默认的属性是BoxFit.contain，child在FittedBox范围内，尽可能的大，但是不超出其尺寸。这里注意一点，contain是保持着child宽高比的大前提下，尽可能的填满，一般情况下，宽度或者高度达到最大值时，就会停止缩放。</li>\n<li>alignment：对齐方式，默认的属性是Alignment.center，居中显示child。</li>\n</ul>\n<h3 id=\"AspectRatio\"><a href=\"#AspectRatio\" class=\"headerlink\" title=\"AspectRatio\"></a>AspectRatio</h3><p>AspectRatio是调整child到设置的宽高比。</p>\n<h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>aspectRatio：aspectRatio是宽高比，最终可能不会根据这个值去布局，具体则要看综合因素，外层是否允许按照这种比率进行布局，只是一个参考值。</p>\n<h3 id=\"ConstrainedBox\"><a href=\"#ConstrainedBox\" class=\"headerlink\" title=\"ConstrainedBox\"></a>ConstrainedBox</h3><p>ConstrainedBox是添加额外的限制条件（constraints）到child上。</p>\n<h3 id=\"UnconstrainedBox\"><a href=\"#UnconstrainedBox\" class=\"headerlink\" title=\"UnconstrainedBox\"></a>UnconstrainedBox</h3><p>UnconstrainedBox刚好与ConstrainedBox相反，是不添加任何约束条件到child上，让child按照其原始的尺寸渲染。</p>\n<h3 id=\"Baseline\"><a href=\"#Baseline\" class=\"headerlink\" title=\"Baseline\"></a>Baseline</h3><p>Baseline会根据child的baseline，来调整child的位置。</p>\n<h4 id=\"属性-3\"><a href=\"#属性-3\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>baseline：baseline数值，必须要有，从顶部算。</li>\n<li>baselineType：baseline类型，也是必须要有的，目前有两种类型：<ul>\n<li>alphabetic：对齐字符底部的水平线；</li>\n<li>ideographic：对齐表意字符的水平线。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"FractionallySizedBox\"><a href=\"#FractionallySizedBox\" class=\"headerlink\" title=\"FractionallySizedBox\"></a>FractionallySizedBox</h3><p>FractionallySizedBox会根据现有空间，来调整child的尺寸。</p>\n<h4 id=\"属性-4\"><a href=\"#属性-4\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>alignment：对齐方式，不能为null。</li>\n<li>widthFactor：宽度因子，跟之前介绍的控件类似，宽度乘以这个值，就是最后的宽度。</li>\n<li>heightFactor：高度因子，用作计算最后实际高度的。</li>\n</ul>\n<p>其中widthFactor和heightFactor都有一个规则</p>\n<ul>\n<li>如果不为null，那么实际的最大宽高度则为child的宽高乘以这个因子；</li>\n<li>如果为null，那么child的宽高则会尽量充满整个区域。</li>\n</ul>\n<h3 id=\"IntrinsicHeight\"><a href=\"#IntrinsicHeight\" class=\"headerlink\" title=\"IntrinsicHeight\"></a>IntrinsicHeight</h3><p>IntrinsicHeight是调整child到固定的高度。</p>\n<h3 id=\"IntrinsicWidth\"><a href=\"#IntrinsicWidth\" class=\"headerlink\" title=\"IntrinsicWidth\"></a>IntrinsicWidth</h3><p>IntrinsicWidth跟IntrinsicHeight类似，是调整child到固定的宽度。</p>\n<h3 id=\"LimitedBox\"><a href=\"#LimitedBox\" class=\"headerlink\" title=\"LimitedBox\"></a>LimitedBox</h3><p>LimitedBox是对child最大宽高进行限制的控件。</p>\n<h3 id=\"Offstage\"><a href=\"#Offstage\" class=\"headerlink\" title=\"Offstage\"></a>Offstage</h3><p>Offstage通过一个参数，来控制控件是否显示。当控件不显示时(offstage为true)，不会响应点击事件，也不会占用空间。</p>\n<h3 id=\"OverflowBox\"><a href=\"#OverflowBox\" class=\"headerlink\" title=\"OverflowBox\"></a>OverflowBox</h3><p>OverflowBox允许child超出parent的范围显示。当OverflowBox的最大尺寸大于child的时候，child可以完整显示，当其小于child的时候，则以最大尺寸为基准，当然，这个尺寸都是可以突破父节点的。最后加上对齐方式，完成布局。</p>\n<h4 id=\"属性-5\"><a href=\"#属性-5\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>alignment：对齐方式。</li>\n<li>minWidth：允许child的最小宽度。如果child宽度小于这个值，则按照最小宽度进行显示。</li>\n<li>maxWidth：允许child的最大宽度。如果child宽度大于这个值，则按照最大宽度进行展示。</li>\n<li>minHeight：允许child的最小高度。如果child高度小于这个值，则按照最小高度进行显示。</li>\n<li>maxHeight：允许child的最大高度。如果child高度大于这个值，则按照最大高度进行展示。<br>其中，最小以及最大宽高度，如果为null的时候，就取父节点的constraint代替。</li>\n</ul>\n<h3 id=\"SizedBox\"><a href=\"#SizedBox\" class=\"headerlink\" title=\"SizedBox\"></a>SizedBox</h3><p>SizedBox用于强制设置child的具体尺寸。</p>\n","categories":[{"name":"Flutter","slug":"Flutter","count":2,"path":"api/categories/Flutter.json"}],"tags":[{"name":"Flutter","slug":"Flutter","count":2,"path":"api/tags/Flutter.json"}]}